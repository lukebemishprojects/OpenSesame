import javax.inject.Inject

plugins {
    id 'java-library'
    id 'opensesame.base'
}

sourceSets {
    transformationTest {}
}

java {
    registerFeature('metafactoryTest') {
        usingSourceSet(sourceSets.create('metafactoryTest'))
        disablePublication()
    }
}

configurations {
    consumable('testSource') {
        outgoing.capability("${project.group}:testtargets-transformation-sources:${project.version}" as String)
        attributes {
            attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, 'java-sources'))
        }
    }
    dependencyScope('compileAsm')
    resolvable('compileAsmClasspath') {
        extendsFrom compileAsm
    }
    dependencyScope('testBundleImplementation')
    resolvable('testBundleClasspath') {
        extendsFrom testBundleImplementation
    }
}

dependencies {
    transformationTestImplementation project(':opensesame-core')
    transformationTestImplementation libs.asm.core
    transformationTestImplementation libs.bundles.junit.implementation
    transformationTestImplementation project(':testtargets')

    metafactoryTestCompileOnly libs.jetbrains.annotations
    
    metafactoryTestImplementation project(':opensesame-core')
    metafactoryTestImplementation project(':opensesame-natives')
    metafactoryTestImplementation project(':opensesame-javac')
    metafactoryTestImplementation libs.asm.core
    metafactoryTestImplementation libs.junit.platform.launcher
    metafactoryTestImplementation libs.apiguardian // Needed so that we can compile stuff at runtime against junit

    metafactoryTestRuntimeOnly libs.bundles.junit.runtime
    metafactoryTestImplementation libs.bundles.junit.implementation

    metafactoryTestImplementation project(':testtargets')
    
    testBundleImplementation(project(':testtargets')) {
        capabilities {
            requireFeature 'metafactory-test'
        }
    }

    compileAsm(project(':opensesame-compile')) {
        capabilities {
            requireFeature 'asm'
        }
    }
}

def tempClassesDir = layout.buildDirectory.dir("tempClasses/compileJava")

tasks.named('compileMetafactoryTestJava', JavaCompile).configure {
    options.javaModuleMainClass = 'dev.lukebemish.opensesame.test.framework.Framework'
    destinationDirectory.set(tempClassesDir)
}

var processTestClasses = tasks.register('processMetafactoryTestClasses', JavaExec) {
    dependsOn tasks.compileMetafactoryTestJava
    dependsOn configurations.compileAsmClasspath
    inputs.dir(tempClassesDir)
    var singleFile = sourceSets.metafactoryTest.output.classesDirs.singleFile;
    doFirst {
        if (singleFile.exists()) {
            singleFile.deleteDir()
        }
        singleFile.mkdirs()
    }
    inputs.files(configurations.compileAsmClasspath)
    outputs.dir(singleFile)
    classpath = configurations.compileAsmClasspath
    mainClass.set 'dev.lukebemish.opensesame.compile.asm.VisitingProcessor'
    args = [tempClassesDir.get().asFile.canonicalPath, singleFile.canonicalPath]
}

tasks.metafactoryTestClasses.dependsOn processMetafactoryTestClasses

artifacts {
    testSource(sourceSets.transformationTest.java.sourceDirectories.singleFile) {
        type 'directory'
        classifier 'testsources'
    }
}

abstract class SetupJunitEnvironment extends DefaultTask {
    @OutputDirectory
    abstract DirectoryProperty getOutputDirectory()

    @InputFiles
    @PathSensitive(PathSensitivity.NAME_ONLY)
    abstract ConfigurableFileCollection getClasspath()
    
    @Input
    abstract ListProperty<String> getJvmArgs()

    @Inject
    SetupJunitEnvironment() {}

    @Inject
    abstract FileSystemOperations getFileSystemOperations()

    @TaskAction
    void run() {
        getOutputDirectory().get().asFile.deleteDir()
        getOutputDirectory().get().asFile.mkdirs()
        fileSystemOperations.copy {
            from classpath
            into getOutputDirectory().get().dir('libraries')
        }
        def argFile = getOutputDirectory().get().file('args.txt')
        def args = []
        args.addAll(jvmArgs.get())
        args.add('--module-path')
        args.add('libraries')
        args.add('--module')
        args.add('dev.lukebemish.opensesame.test.metafactory')
        argFile.getAsFile().text = args.join(' ')
    }
}

tasks.register('setupTestEnvironment', SetupJunitEnvironment) {
    dependsOn tasks.metafactoryTestJar
    outputDirectory.set(layout.buildDirectory.dir('testEnvironment'))
    classpath.from configurations.testBundleClasspath
    jvmArgs.addAll([
            '-ea',
            
            // Avoid warnings; native access is necessary for these components (FFI and native lookup providers)
            '--enable-native-access=dev.lukebemish.opensesame.core',
            '--enable-native-access=dev.lukebemish.opensesame.natives',
            
            // Necessary for opensesame-javac, for use in the module layer framework
            '--add-exports=jdk.compiler/com.sun.tools.javac.api=dev.lukebemish.javacpostprocessor',
            '--add-exports=jdk.compiler/com.sun.tools.javac.jvm=dev.lukebemish.javacpostprocessor',
            '--add-exports=jdk.compiler/com.sun.tools.javac.util=dev.lukebemish.javacpostprocessor',

            // Let our test framework test the native-access bits
            '--add-opens=dev.lukebemish.opensesame.natives/dev.lukebemish.opensesame.natives=dev.lukebemish.opensesame.test.metafactory',
            '--add-opens=dev.lukebemish.opensesame.core/dev.lukebemish.opensesame.runtime=dev.lukebemish.opensesame.test.metafactory'
    ])
}

tasks.register('metafactoryTest', JavaExec) {
    dependsOn tasks.setupTestEnvironment
    inputs.files(tasks.setupTestEnvironment.outputDirectory)
    
    javaLauncher = javaToolchains.launcherFor {
        languageVersion.set(JavaLanguageVersion.of(22))
    }
    workingDir(tasks.setupTestEnvironment.outputDirectory)
    jvmArgs(tasks.setupTestEnvironment.jvmArgs.get())
    classpath(configurations.testBundleClasspath)
    modularity.inferModulePath = true
    mainModule = 'dev.lukebemish.opensesame.test.metafactory'
}
