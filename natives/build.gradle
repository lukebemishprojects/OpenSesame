import dev.lukebemish.ziggradle.toolchain.ZigVersion
import dev.lukebemish.ziggradle.ZigCompileTask
import dev.lukebemish.ziggradle.ZigArchitectureTarget
import dev.lukebemish.ziggradle.ZigOperatingSystemTarget
import dev.lukebemish.ziggradle.ZigArtifactType
import javax.inject.Inject

plugins {
    id 'opensesame.conventions'
    id 'dev.lukebemish.zig-gradle'
}

java.withSourcesJar()
java.withJavadocJar()

def targets = [
        'linux': ['x86_64', 'aarch64', 'i386', 'arm'],
        'windows': ['x86_64', 'aarch64', 'i386'],
        'macos': ['x86_64', 'aarch64']
]

def targetfinder = [
        'linux': 'libopensesamenative.so',
        'windows': 'opensesamenative.dll',
        'macos': 'libopensesamenative.dylib'
]

zig {
    toolchain {
        version = ZigVersion.of('0.14.0')
    }
}

tasks.named('compileJava', JavaCompile) {
    options.headerOutputDirectory.set(project.layout.buildDirectory.dir("headers/main"))
}

def registerZigCompile(String os, String arch, String finalName) {
    def archmap = [
            'x86_64': ZigArchitectureTarget.X86_64,
            'aarch64': ZigArchitectureTarget.AARCH64,
            'i386': ZigArchitectureTarget.X86,
            'arm': objects.named(ZigArchitectureTarget, 'arm')
    ]

    def jniHeaders = [
            'linux': zig.jniHeadersUnixOpenJDK("tags/jdk-17+35"),
            'windows': zig.jniHeadersWindowsOpenJDK("tags/jdk-17+35"),
            'macos': zig.jniHeadersUnixOpenJDK("tags/jdk-17+35")
    ]

    return project.tasks.register('zigCompile-'+os+'-'+arch, ZigCompileTask) {
        zigCompiler = zig.compilerFor {}
        options {
            artifactType = ZigArtifactType.LIBRARY
            compilerArgs.addAll([
                    "--gc-sections",
                    "-lc",
                    "-ffunction-sections",
                    "-fdata-sections",
                    "-cflags",
                    "-nostdlib",
                    "-nobuiltininc",
                    "--",
                    "-O",
                    "ReleaseSmall"
            ])
            targetOperatingSystem = objects.named(ZigOperatingSystemTarget, os)
            targetArchitecture = archmap[arch]
            dynamic = true
        }
        baseArtifactName = "opensesamenative"
        headers.from(tasks.named('compileJava').flatMap { it.options.headerOutputDirectory })
        headers.from(jniHeaders[os])
        sourceFiles.from('src/natives/opensesamenative.c')
        outputDirectory = project.layout.buildDirectory.dir("natives/"+os+'-'+arch)
    }
}

targets.each { os, archs ->
    archs.each { arch ->
        def finalName = targetfinder[os]
        def extension = finalName.split(/\./)[1]
        var task = registerZigCompile(os, arch, finalName)
        ConfigurableFileCollection files = project.objects.fileCollection()
        processResources {
            from(task.flatMap { it.outputDirectory }.map { it.file(finalName) }) {
                into "dev/lukebemish/opensesame/natives/$os/$arch"
            }
            dependsOn task
        }
    }
}

configurations {
    runtimeElements {
        outgoing.variants.clear()
    }
    apiElements {
        outgoing.variants.clear()
    }
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            pom {
                openSesameConvention.pomShared(it, 'Core')
                description = 'Native code for OpenSesame, a tool for typesafe access to normally inaccessible members'
            }
        }
    }
}

sourceSets {
    testnatives {}
}

configurations {
    testBundle {
        canBeResolved = true
    }
    testnativesImplementation.extendsFrom testBundle
}

dependencies {
    testBundle libs.junit.api
    testBundle libs.junit.engine
    testBundle libs.junit.console
    testBundle libs.junit.junit
    testBundle project(':opensesame-natives')
}

abstract class SetupJunitEnvironment extends DefaultTask {
    @OutputDirectory
    abstract DirectoryProperty getOutputDirectory()

    @InputFiles
    @PathSensitive(PathSensitivity.NAME_ONLY)
    abstract ConfigurableFileCollection getClasspath()

    @InputFiles
    @PathSensitive(PathSensitivity.RELATIVE)
    abstract ConfigurableFileCollection getTestClasses()

    @Inject
    SetupJunitEnvironment() {}

    @Inject
    abstract FileSystemOperations getFileSystemOperations()

    @TaskAction
    void run() {
        getOutputDirectory().get().asFile.deleteDir()
        getOutputDirectory().get().asFile.mkdirs()
        fileSystemOperations.copy {
            from classpath
            into getOutputDirectory().get()
        }
        fileSystemOperations.copy {
            from testClasses
            into getOutputDirectory().get().dir('testclasses')
        }
        def unixargfile = getOutputDirectory().get().file('args-linux.txt')
        def macosargfile= getOutputDirectory().get().file('args-macos.txt')
        def winargfile = getOutputDirectory().get().file('args-windows.txt')
        def args = []
        def filenames = classpath.files.collect { it.name }
        args.add('-cp')
        args.add(filenames.join(':'))
        args.add('org.junit.platform.console.ConsoleLauncher')
        args.add('execute')
        args.add('--fail-if-no-tests')
        args.add('--class-path=testclasses')
        testClasses.files.each { outer ->
            outer.eachFileRecurse(groovy.io.FileType.FILES) { classFile ->
                def className = outer.relativePath(classFile).replace('/', '.').replace('\\', '.')
                if (className.endsWith('.class')) {
                    args.add('--select-class=' + className[0..-7])
                }
            }
        }
        args.add('--reports-dir=results')
        unixargfile.getAsFile().text = args.join(' ')
        macosargfile.getAsFile().text = args.join(' ')
        winargfile.getAsFile().text = args.join(' ').replace(':', ';')
    }
}

tasks.register('setupTestEnvironment', SetupJunitEnvironment) {
    dependsOn tasks.testnativesClasses
    outputDirectory.set(layout.buildDirectory.dir('testEnvironment'))
    classpath.from configurations.testBundle
    testClasses.from sourceSets.testnatives.output.classesDirs
}

